# -*- coding: utf-8 -*-
"""
Created on Wed Apr 15 10:51:48 2020

This code solves viscous Burger's Eqn using fourth order finite difference schemes and
the RK4 multi-step method.

Snapshots are generated by forming a randomly generated initial condition and propagating in time.
Many snapshots are saved.

@author: Christian Jacobsen 
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import diags
from scipy.stats import truncnorm
from mpl_toolkits import mplot3d
import scipy.io as sio
from scipy.fftpack import fft, ifft

plt.close('all')

def F(u, visc, dx):
    n = np.size(u) 
    diags1 = [16, -1, -1, 16, -30, 16, -1, -1, 16]
    diags2 = [8, -1, 1, -8, 0, 8, -1, 1, -8]
    mat1 = diags(diags1, [-n+1, -n+2, -2, -1, 0, 1, 2, n-2, n-1], shape = (n,n)).toarray()
    mat2 = diags(diags2, [-n+1, -n+2, -2, -1, 0, 1, 2, n-2, n-1], shape = (n,n)).toarray()
    mat2 = mat2@u 
    mat2 = np.multiply(mat2,u) 
    f = visc/(12*dx*dx)*mat1@u - 1/(12*dx)*mat2 
    return f

def RK4(u0, dx, dt, nsteps, visc, F):
    n = np.size(u0) 
    Uplot = np.zeros((n,nsteps)) 
    Uplot[:,0] = u0.reshape((n,))
    T = np.zeros(nsteps) 
    U = [u0] 
    
    for i in range(nsteps-1):
        k1 = F(Uplot[:,i], visc, dx)
        k2 = F(Uplot[:,i]+dt*k1/2, visc, dx)
        k3 = F(Uplot[:,i]+dt*k2/2, visc, dx)
        k4 = F(Uplot[:,i]+dt*k3, visc, dx)
        Uplot[:,i+1] = Uplot[:,i] + dt/6*(k1 + 2*k2 + 2*k3 + k4)
        U.append(Uplot[:,i+1])
        T[i+1] = T[i] + dt

    return U, Uplot, T

def IC(out_mesh, batch_size = 1):
    ## initial condition
#    krange = ((out_mesh/8)*np.pi/l - 4 * np.pi/l) * np.random.rand(batch_size, 1) + 4 * np.pi/l
#    envelope = np.exp(-1/(2*krange**2) * k**2)
#    v0 = envelope * (np.random.normal(loc=0, scale=1.0, size=(batch_size, mesh)) 
#                        + 1j*np.random.normal(loc=0, scale=1.0, size=(batch_size, mesh)))
#    u0 = np.real(ifft(v0)) 
#    u0 = np.sqrt(mesh) * u0/np.expand_dims(np.linalg.norm(u0, axis=-1), axis=-1) # normalize
#    v0 = fft(u0) 
    n = np.size(out_mesh)
    u0 = -0.5*np.cos(2*np.pi*out_mesh)+0.5 
    u0 = np.reshape(u0, (n,1)) 
    r = np.random.randint(0, n)
    u0 = np.roll(u0, r) 
    return u0, r

def main():

    n_times = 2
    n_snapshots = int(5000)#int(1000)
    n_slice = int(10)
    t_steps = int(128 * n_slice * n_times)
    t_save = int(128) * n_times
    n_nodes = int(128)
    viscosity = 0.002 # minimum is 0.002 found empirically, max is 0.02
    cfl = 0.2
    slice_inds = np.linspace(0, t_steps - n_slice, t_save)
    slice_inds = np.round(slice_inds).astype(int)
    data_list = []
    param_list = []
    ic_param_list = []

    x0 = np.linspace(0,1,n_nodes)
    dx = x0[1]-x0[0]
    dt = cfl*dx 

    mean = 0.0125
    std = 0.005
    a = (0.002 - mean) / std
    b = (0.02 - mean) / std

    #v_vec = np.linspace(0.002, 0.02, 50)

    for i in range(n_snapshots):
        print(i)
        u0, r = IC(x0)
        #v = np.random.rand()*(0.02 - 0.002) + 0.002
        #v = truncnorm.rvs(a, b, loc=mean, scale=std)
        v = np.random.uniform()*(0.02-0.002)+0.002
        #v = v_vec[i]
        _, U, T = RK4(u0, dx, dt, t_steps, v, F)
        v = [v]
        U = U[:, slice_inds]
        U = np.transpose(U)
        U = np.reshape(U, (1, t_save, n_nodes)).astype(np.float32)
        param_list.append(v)
        data_list.append(U)
        ic_param_list.append(r)

    data_list = np.concatenate(data_list)
    data_list = np.reshape(data_list, (n_snapshots, 1, t_save, n_nodes))
    param_list = np.concatenate(param_list)
    ic_param_list = np.array(ic_param_list)
    param_list = np.reshape(param_list, (n_snapshots, 1))
    ic_param_list = np.reshape(ic_param_list, (n_snapshots, 1))

    # concatenate the initial condition parameters and gama
    param_list = np.concatenate((param_list, ic_param_list), axis=1)

    print(np.shape(data_list))
    print(np.shape(param_list))
    print(int(t_steps/n_slice))

    T = T[slice_inds]

    plt.figure(1)
    plt.plot(x0,U[0, 0, :])
    plt.plot(x0,U[0, -1, :])

    '''
    X,TT = np.meshgrid(x0,T)
    plt.figure(2)
    ax = plt.axes() 
    ax.contourf(TT, X, U[0, :, :], 50, cmap = 'viridis', alpha = 1)
    plt.xlabel('t')
    plt.ylabel('x')
    ax.set_title('Viscous Burgers Solution')
#ax.set_zlabel('u')

# include to output single time snapshots
    data_list_mat = data_list[0]
    data_list = []
    data_list1 = []
    for i in range(t_save-1):
        temp = data_list_mat[0, i, :]
        temp = np.reshape(temp, (1, n_nodes))
        temp1 = data_list_mat[0, i + 1, :]
        temp1 = np.reshape(temp1, (1, n_nodes))
        data_list.append(temp)
        data_list1.append(temp1)
    '''

    print(np.shape(data_list))


#sio.savemat('viscous_burgers_prediction_data.mat', {'U':np.transpose(U), 't':T, 'x':x0, 'dx':dx, 'dt':dt})
    np.savez('VB_dataset_train.npz', x = data_list, params = param_list)
#print(np.shape(data_list))
#print(np.shape(param_list))

if __name__ == "__main__":
    main()
